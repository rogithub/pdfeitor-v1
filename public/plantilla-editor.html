<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pdfeitor V1: Editor de Plantillas Multi-página</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
    <style>
        #image-preview-container.cropper-bg { background: none; }
        .cropper-container { max-height: 60vh; }
    </style>
</head>
<body>
    <aside id="controls">
        <h1>Editor de Plantillas</h1>
        <p class="info-text" style="margin-top: -10px; margin-bottom: 20px;">
            <a href="/">&#8592; Volver al Menú</a>
        </p>
        
        <div class="control-group">
            <h3>1. Configuración Global</h3>
            <label for="pageSize">Tamaño de Página</label>
            <select id="pageSize"><option value="letter">Carta</option><option value="legal">Oficio</option></select>
            <label for="orientation" style="margin-top: 10px;">Orientación</label>
            <select id="orientation"><option value="portrait">Vertical</option><option value="landscape">Horizontal</option></select>
            <label for="margin" style="margin-top: 10px;">Margen (mm)</label>
            <input type="number" id="margin" value="10" min="0">
        </div>

        <div class="control-group">
            <h3>2. Plantilla de Cuadrícula</h3>
            <label for="base-cols">Columnas</label>
            <input type="number" id="base-cols" value="2" min="1">
            <label for="base-rows" style="margin-top: 10px;">Filas</label>
            <input type="number" id="base-rows" value="2" min="1">
            <label for="spacing" style="margin-top: 10px;">Espaciado (mm)</label>
            <input type="number" id="spacing" value="5" min="0">
            <button id="apply-template-btn">Aplicar Plantilla a Imágenes</button>
        </div>

        <div class="control-group">
            <h3>3. Cargar Imágenes</h3>
            <input type="file" id="image-input-batch" accept="image/*,.zip" multiple>
            <button id="clear-images-btn" class="btn-clear">Limpiar Todo</button>
        </div>
        
        <div class="control-group" id="cell-actions-group" style="display: none;">
            <h3>4. Acciones de Celda</h3>
            <p class="info-text">(Mantén <b>Ctrl</b> para seleccionar celdas en la página activa)</p>
            <button id="merge-cells-btn" disabled>Combinar Celdas</button>
            <button id="split-cells-btn" class="btn-split" disabled>Separar Celda</button>
        </div>

        <div class="control-group" style="margin-top: auto;">
            <h3>5. Finalizar</h3>
            <button id="generate-pdf-btn" class="btn-generate" disabled>Generar PDF</button>
        </div>
    </aside>

    <main id="main-content">
        <div id="preview-area">
            <h2 id="page-indicator" style="text-align: center; margin-bottom: 10px;">Página 1</h2>
            <div id="design-container">
                <div id="grid-container"></div>
            </div>
        </div>
        <aside id="page-thumbnails">
            <p style="text-align: center; color: #6c757d;">Carga imágenes para ver las páginas.</p>
        </aside>
    </main>

    <div id="image-modal">
        <div class="modal-content">
            <h2>Editar Celda</h2>
            <label for="image-input-single">Seleccionar Imagen:</label>
            <input type="file" id="image-input-single" accept="image/*">
            <div id="image-preview-container"><img id="image-preview" src=""></div>
            <div class="modal-actions" id="standard-modal-actions">
                <button id="crop-image-btn">Recortar</button>
                <button id="rotate-image-btn">Girar 90°</button>
                <button id="remove-image-btn" class="btn-remove">Quitar Imagen</button>
            </div>
            <div class="modal-actions" id="crop-modal-actions" style="display: none;">
                <button id="confirm-crop-btn" class="btn-generate">Confirmar</button>
                <button id="cancel-crop-btn" class="btn-cancel">Cancelar Recorte</button>
            </div>
            <hr>
            <div class="modal-actions">
                <button id="cancel-modal-btn" class="btn-cancel">Cancelar</button>
                <button id="save-image-btn" class="btn-generate">Guardar</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
    <script src="/js/constants.js"></script>
    <script src="/js/ui.js"></script>
    <script src="/js/fileHandler.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- STATE MANAGEMENT ---
            let state = {
                pageSettings: { pageSize: 'letter', orientation: 'portrait', margin: 10 },
                template: { baseCols: 2, baseRows: 2, spacing: 5 },
                pages: [],
                imageFiles: [],
                activePageIndex: 0,
                selectedCellIds: new Set(),
                activeModalCellId: null,
                currentModalRotation: 0,
                currentModalFile: null,
                originalModalImageUrl: null
            };
            let cropper = null;

            // --- DOM ELEMENTS ---
            const pageSizeSelect = document.getElementById('pageSize');
            const orientationSelect = document.getElementById('orientation');
            const marginInput = document.getElementById('margin');
            const baseColsInput = document.getElementById('base-cols');
            const baseRowsInput = document.getElementById('base-rows');
            const spacingInput = document.getElementById('spacing');
            const applyTemplateBtn = document.getElementById('apply-template-btn');
            const imageInputBatch = document.getElementById('image-input-batch');
            const clearImagesBtn = document.getElementById('clear-images-btn');
            const cellActionsGroup = document.getElementById('cell-actions-group');
            const mergeBtn = document.getElementById('merge-cells-btn');
            const splitBtn = document.getElementById('split-cells-btn');
            const generatePdfBtn = document.getElementById('generate-pdf-btn');
            const pageIndicator = document.getElementById('page-indicator');
            const designContainer = document.getElementById('design-container');
            const gridContainer = document.getElementById('grid-container');
            const thumbnailsContainer = document.getElementById('page-thumbnails');
            const previewArea = document.getElementById('preview-area');
            // Modal elements
            const imageModal = document.getElementById('image-modal');
            const imageInputSingle = document.getElementById('image-input-single');
            const imagePreview = document.getElementById('image-preview');
            const imagePreviewContainer = document.getElementById('image-preview-container');
            const rotateBtn = document.getElementById('rotate-image-btn');
            const removeBtn = document.getElementById('remove-image-btn');
            const saveBtn = document.getElementById('save-image-btn');
            const cancelBtn = document.getElementById('cancel-modal-btn');
            const cropBtn = document.getElementById('crop-image-btn');
            const confirmCropBtn = document.getElementById('confirm-crop-btn');
            const cancelCropBtn = document.getElementById('cancel-crop-btn');
            const standardModalActions = document.getElementById('standard-modal-actions');
            const cropModalActions = document.getElementById('crop-modal-actions');

            let px_per_mm = 1;

            // --- CORE LOGIC ---

            function createCellState(id, c, r) {
                return { id, col: c, row: r, colSpan: 1, rowSpan: 1, visible: true, merged: false, mergedInto: null, image: { file: null, url: null, rotation: 0, name: null } };
            }

            function createPageFromTemplate() {
                const { baseCols, baseRows } = state.template;
                const newPage = { baseCols, baseRows, cells: [] };
                for (let r = 0; r < baseRows; r++) {
                    for (let c = 0; c < baseCols; c++) {
                        const id = r * baseCols + c;
                        newPage.cells.push(createCellState(id, c, r));
                    }
                }
                return newPage;
            }

            function applyTemplate() {
                state.template.baseCols = parseInt(baseColsInput.value, 10);
                state.template.baseRows = parseInt(baseRowsInput.value, 10);
                state.template.spacing = parseFloat(spacingInput.value);
                
                distributeImagesToPages();
                selectPage(0);
            }

            async function handleBatchImageUpload(e) {
                const files = e.target.files;
                state.imageFiles = await processFiles(files);
                await distributeImagesToPages();
            }

            async function distributeImagesToPages() {
                state.pages = [];
                if (state.imageFiles.length === 0) {
                    state.pages.push(createPageFromTemplate());
                    render();
                    return;
                }

                const { pageSize, orientation, margin } = state.pageSettings;
                const { baseCols, baseRows, spacing } = state.template;

                const pageDims = PAPER_DIMENSIONS_MM[pageSize];
                const pageWidthMM = orientation === 'landscape' ? pageDims.height : pageDims.width;
                const pageHeightMM = orientation === 'landscape' ? pageDims.width : pageDims.height;

                const drawableWidthMM = pageWidthMM - (2 * margin);
                const drawableHeightMM = pageHeightMM - (2 * margin);

                const cellWidthMM = (drawableWidthMM - (baseCols - 1) * spacing) / baseCols;
                const cellHeightMM = (drawableHeightMM - (baseRows - 1) * spacing) / baseRows;
                const cellIsLandscape = cellWidthMM > cellHeightMM;
                
                const imageProcessingPromises = state.imageFiles.map(file => {
                    return new Promise(resolve => {
                        const imageUrl = URL.createObjectURL(file);
                        const img = new Image();
                        img.onload = () => {
                            const imageIsLandscape = img.naturalWidth > img.naturalHeight;
                            const rotation = (imageIsLandscape !== cellIsLandscape) ? 90 : 0;
                            resolve({ file, url: imageUrl, rotation, name: file.name });
                        };
                        img.onerror = () => { // Handle cases where the image can't be loaded
                            console.error("Could not load image:", file.name);
                            resolve(null);
                        };
                        img.src = imageUrl;
                    });
                });

                const processedImages = (await Promise.all(imageProcessingPromises)).filter(Boolean); // Filter out nulls from errors

                let imageIndex = 0;
                while (imageIndex < processedImages.length) {
                    const newPage = createPageFromTemplate();
                    newPage.cells.forEach(cell => {
                        if (imageIndex < processedImages.length) {
                            cell.image = processedImages[imageIndex];
                            imageIndex++;
                        }
                    });
                    state.pages.push(newPage);
                }

                if (state.pages.length === 0) {
                    state.pages.push(createPageFromTemplate());
                }
                selectPage(0);
            }
            
            function clearAll() {
                state.imageFiles.forEach(file => URL.revokeObjectURL(file.url));
                state.imageFiles = [];
                state.pages = [createPageFromTemplate()];
                selectPage(0);
            }

            // --- RENDER LOGIC ---

            function render() {
                px_per_mm = updateDesignArea({
                    ...state.pageSettings,
                    useHalfPage: false,
                    containerElement: designContainer,
                    areaElement: previewArea
                });
                renderGrid();
                renderThumbnails();
                updateControlsState();
            }

            function renderGrid() {
                const page = state.pages[state.activePageIndex];
                if (!page) return;

                const { baseCols } = page;
                const spacing_px = state.template.spacing * px_per_mm;

                gridContainer.innerHTML = '';
                gridContainer.style.gridTemplateColumns = `repeat(${baseCols}, 1fr)`;
                gridContainer.style.gridTemplateRows = `repeat(${page.baseRows}, 1fr)`;
                gridContainer.style.gap = `${spacing_px}px`;

                page.cells.forEach(cell => {
                    if (!cell.visible) return;
                    const cellEl = document.createElement('div');
                    cellEl.className = 'grid-cell';
                    cellEl.dataset.id = cell.id;
                    cellEl.style.gridColumn = `span ${cell.colSpan}`;
                    cellEl.style.gridRow = `span ${cell.rowSpan}`;

                    const imageContainer = document.createElement('div');
                    imageContainer.className = 'image-container';
                    if (cell.image.url) {
                        imageContainer.style.backgroundImage = `url(${cell.image.url})`;
                        imageContainer.style.transform = `rotate(${cell.image.rotation}deg)`;
                    }
                    if (state.selectedCellIds.has(cell.id)) {
                        cellEl.classList.add('selected');
                    }
                    cellEl.appendChild(imageContainer);
                    gridContainer.appendChild(cellEl);
                });
            }

            function renderThumbnails() {
                thumbnailsContainer.innerHTML = '';
                if (state.pages.length === 0 || (state.pages.length === 1 && state.imageFiles.length === 0)) {
                     thumbnailsContainer.innerHTML = '<p style="text-align: center; color: #6c757d;">Carga imágenes para ver las páginas.</p>';
                     return;
                }

                state.pages.forEach((page, index) => {
                    const thumb = document.createElement('div');
                    thumb.className = 'thumbnail';
                    thumb.dataset.index = index;
                    if (index === state.activePageIndex) thumb.classList.add('selected');

                    const img = document.createElement('img');
                    const firstImageCell = page.cells.find(c => c.image.url);
                    img.src = firstImageCell ? firstImageCell.image.url : 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
                    
                    const pageNum = document.createElement('span');
                    pageNum.className = 'thumb-page-number';
                    pageNum.textContent = index + 1;

                    thumb.appendChild(img);
                    thumb.appendChild(pageNum);
                    thumbnailsContainer.appendChild(thumb);
                });
            }

            function selectPage(index) {
                if (index >= 0 && index < state.pages.length) {
                    state.activePageIndex = index;
                    state.selectedCellIds.clear();
                    pageIndicator.textContent = `Página ${index + 1}`;
                    render();
                }
            }

            // --- UI & CONTROLS UPDATE ---

            function updateControlsState() {
                generatePdfBtn.disabled = state.imageFiles.length === 0;
                cellActionsGroup.style.display = state.pages.length > 0 ? 'block' : 'none';
                
                const selectedCount = state.selectedCellIds.size;
                mergeBtn.disabled = selectedCount < 2;
                splitBtn.disabled = true;
                if (selectedCount === 1) {
                    const page = state.pages[state.activePageIndex];
                    const selectedCell = page.cells.find(c => c.id === state.selectedCellIds.values().next().value);
                    if (selectedCell && selectedCell.merged) {
                        splitBtn.disabled = false;
                    }
                }
            }
            
            function updatePageSettings() {
                state.pageSettings.pageSize = pageSizeSelect.value;
                state.pageSettings.orientation = orientationSelect.value;
                state.pageSettings.margin = parseFloat(marginInput.value);
                render();
            }

            // --- CELL & MODAL ACTIONS ---

            function handleCellClick(e) {
                const cell = e.target.closest('.grid-cell');
                if (!cell) return;
                const id = parseInt(cell.dataset.id, 10);
                if (e.ctrlKey || e.metaKey) {
                    state.selectedCellIds.has(id) ? state.selectedCellIds.delete(id) : state.selectedCellIds.add(id);
                } else {
                    state.selectedCellIds.clear();
                    openImageModal(id);
                }
                renderGrid();
                updateControlsState();
            }

            function mergeCells() {
                const page = state.pages[state.activePageIndex];
                const selectedCells = Array.from(state.selectedCellIds).map(id => page.cells.find(c => c.id === id));
                const minRow = Math.min(...selectedCells.map(c => c.row));
                const maxRow = Math.max(...selectedCells.map(c => c.row + c.rowSpan - 1));
                const minCol = Math.min(...selectedCells.map(c => c.col));
                const maxCol = Math.max(...selectedCells.map(c => c.col + c.colSpan - 1));
                const colSpan = maxCol - minCol + 1;
                const rowSpan = maxRow - minRow + 1;

                let totalCellsInRect = 0;
                page.cells.forEach(c => {
                    if(c.visible && c.row >= minRow && (c.row + c.rowSpan - 1) <= maxRow && c.col >= minCol && (c.col + c.colSpan - 1) <= maxCol) {
                        totalCellsInRect++;
                    }
                });
                if (selectedCells.length !== totalCellsInRect) {
                    alert('La selección debe formar un rectángulo perfecto sin celdas combinadas previamente.');
                    return;
                }

                const anchorCell = page.cells.find(c => c.row === minRow && c.col === minCol);
                anchorCell.colSpan = colSpan;
                anchorCell.rowSpan = rowSpan;
                anchorCell.merged = true;

                selectedCells.forEach(cell => {
                    if (cell.id !== anchorCell.id) {
                        cell.visible = false;
                        cell.mergedInto = anchorCell.id;
                    }
                });
                state.selectedCellIds.clear();
                state.selectedCellIds.add(anchorCell.id);
                render();
            }

            function splitCell() {
                const page = state.pages[state.activePageIndex];
                const anchorId = state.selectedCellIds.values().next().value;
                const anchorCell = page.cells.find(c => c.id === anchorId);
                if (!anchorCell || !anchorCell.merged) return;

                page.cells.forEach(cell => {
                    if (cell.mergedInto === anchorId) {
                        cell.visible = true;
                        cell.mergedInto = null;
                    }
                });
                anchorCell.colSpan = 1;
                anchorCell.rowSpan = 1;
                anchorCell.merged = false;
                state.selectedCellIds.clear();
                render();
            }

            function openImageModal(cellId) {
                state.activeModalCellId = cellId;
                const cell = state.pages[state.activePageIndex].cells.find(c => c.id === cellId);
                state.currentModalRotation = cell.image.rotation;
                state.currentModalFile = cell.image.file;
                state.originalModalImageUrl = cell.image.url;
                imagePreview.src = cell.image.url || '';
                imagePreview.style.transform = `rotate(${state.currentModalRotation}deg)`;
                imageInputSingle.value = '';
                imageModal.style.display = 'flex';
                cropBtn.disabled = !state.currentModalFile;
            }

            function closeModal() {
                if (cropper) cropper.destroy();
                cropper = null;
                imagePreview.style.display = 'block';
                imagePreviewContainer.classList.remove('cropper-bg');
                standardModalActions.style.display = 'flex';
                cropModalActions.style.display = 'none';
                imageModal.style.display = 'none';
            }

            function handleModalImageUpload(e) {
                if (e.target.files[0]) {
                    state.currentModalFile = e.target.files[0];
                    state.originalModalImageUrl = URL.createObjectURL(state.currentModalFile);
                    imagePreview.src = state.originalModalImageUrl;
                    cropBtn.disabled = false;

                    const img = new Image();
                    img.onload = () => {
                        const page = state.pages[state.activePageIndex];
                        const cellState = page.cells.find(c => c.id === state.activeModalCellId);
                        const cellElement = gridContainer.querySelector(`[data-id="${cellState.id}"]`);
                        if (!cellElement) return;

                        const imageIsLandscape = img.naturalWidth > img.naturalHeight;
                        const cellIsLandscape = cellElement.clientWidth > cellElement.clientHeight;

                        state.currentModalRotation = (imageIsLandscape !== cellIsLandscape) ? 90 : 0;
                        imagePreview.style.transform = `rotate(${state.currentModalRotation}deg)`;
                    };
                    img.src = state.originalModalImageUrl;
                }
            }

            function cropImage() {
                if (!state.originalModalImageUrl) return;
                imagePreview.style.display = 'none';
                imagePreviewContainer.classList.add('cropper-bg');
                
                const img = document.createElement('img');
                img.src = state.originalModalImageUrl;
                imagePreviewContainer.appendChild(img);

                cropper = new Cropper(img, { viewMode: 1, background: false });
                standardModalActions.style.display = 'none';
                cropModalActions.style.display = 'flex';
            }

            function confirmCrop() {
                if (!cropper) return;
                const canvas = cropper.getCroppedCanvas();
                canvas.toBlob((blob) => {
                    const newFile = new File([blob], state.currentModalFile.name, { type: blob.type });
                    state.currentModalFile = newFile;
                    state.originalModalImageUrl = URL.createObjectURL(newFile);
                    imagePreview.src = state.originalModalImageUrl;
                    cancelCrop();
                }, state.currentModalFile.type);
            }

            function cancelCrop() {
                if (cropper) cropper.destroy();
                cropper = null;
                imagePreviewContainer.innerHTML = '';
                imagePreviewContainer.appendChild(imagePreview);
                imagePreview.style.display = 'block';
                imagePreviewContainer.classList.remove('cropper-bg');
                standardModalActions.style.display = 'flex';
                cropModalActions.style.display = 'none';
            }

            function saveImage() {
                const cell = state.pages[state.activePageIndex].cells.find(c => c.id === state.activeModalCellId);
                cell.image.file = state.currentModalFile;
                cell.image.rotation = state.currentModalRotation;
                cell.image.url = state.currentModalFile ? URL.createObjectURL(state.currentModalFile) : null;
                cell.image.name = state.currentModalFile ? state.currentModalFile.name : null;
                render();
                closeModal();
            }

            // --- PDF GENERATION ---
            async function generatePdf() {
                generatePdfBtn.disabled = true;
                generatePdfBtn.textContent = 'Generando...';

                const formData = new FormData();
                const config = {
                    pageSettings: {
                        ...state.pageSettings,
                        spacing: state.template.spacing
                    },
                    pages: []
                };

                config.pages = state.pages.map((page, pageIndex) => {
                    const pageData = {
                        baseCols: page.baseCols,
                        baseRows: page.baseRows,
                        cells: page.cells.map(cell => {
                            const cellData = {
                                id: cell.id, col: cell.col, row: cell.row,
                                colSpan: cell.colSpan, rowSpan: cell.rowSpan,
                                visible: cell.visible, merged: cell.merged,
                                mergedInto: cell.mergedInto,
                                image: { rotation: 0, name: null }
                            };

                            if (cell.image && cell.image.file) {
                                const uniqueName = `p${pageIndex}_c${cell.id}_${cell.image.file.name}`;
                                cellData.image.name = uniqueName;
                                cellData.image.rotation = cell.image.rotation;

                                // Usar el método de 3 argumentos para asegurar que el nombre del archivo se envíe correctamente
                                formData.append('images', cell.image.file, uniqueName);
                            }
                            return cellData;
                        })
                    };
                    return pageData;
                });

                formData.append('config', JSON.stringify(config));

                try {
                    const response = await fetch('/generate-plantilla', { method: 'POST', body: formData });
                    if (!response.ok) throw new Error(`Error del servidor: ${response.statusText}`);
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'documento_plantilla.pdf';
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    a.remove();
                } catch (error) {
                    console.error('Error al generar PDF:', error);
                    alert('Hubo un error al generar el PDF.');
                } finally {
                    generatePdfBtn.disabled = false;
                    generatePdfBtn.textContent = 'Generar PDF';
                }
            }

            // --- EVENT LISTENERS ---
            pageSizeSelect.addEventListener('change', updatePageSettings);
            orientationSelect.addEventListener('change', updatePageSettings);
            marginInput.addEventListener('input', updatePageSettings);
            window.addEventListener('resize', render);
            applyTemplateBtn.addEventListener('click', applyTemplate);
            imageInputBatch.addEventListener('change', handleBatchImageUpload);
            clearImagesBtn.addEventListener('click', clearAll);
            gridContainer.addEventListener('click', handleCellClick);
            thumbnailsContainer.addEventListener('click', (e) => {
                const thumb = e.target.closest('.thumbnail');
                if (thumb) selectPage(parseInt(thumb.dataset.index, 10));
            });
            mergeBtn.addEventListener('click', mergeCells);
            splitBtn.addEventListener('click', splitCell);
            generatePdfBtn.addEventListener('click', generatePdf);

            // Modal listeners
            cancelBtn.addEventListener('click', closeModal);
            saveBtn.addEventListener('click', saveImage);
            imageInputSingle.addEventListener('change', handleModalImageUpload);
            rotateBtn.addEventListener('click', () => {
                state.currentModalRotation = (state.currentModalRotation + 90) % 360;
                imagePreview.style.transform = `rotate(${state.currentModalRotation}deg)`;
            });
            removeBtn.addEventListener('click', () => {
                state.currentModalFile = null;
                state.currentModalRotation = 0;
                imagePreview.src = '';
                imagePreview.style.transform = 'rotate(0deg)';
                cropBtn.disabled = true;
            });
            cropBtn.addEventListener('click', cropImage);
            confirmCropBtn.addEventListener('click', confirmCrop);
            cancelCropBtn.addEventListener('click', cancelCrop);

            // --- INITIALIZATION ---
            setTimeout(() => { applyTemplate(); }, 0);
        });
    </script>
</body>
</html>